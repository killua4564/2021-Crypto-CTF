from Crypto.Util.number import *

c = 743659173595886457607254543121918708713810510381245768330953896356729957738044997919157767248291296000933234772682933642245078247479241413471916502171546043147216192553356716335136274070289554007061749485849444101635271003381044745855589773953131182187655264797235445777744849647152561564484247268758514302943975733701721041606377051604478696367133131173608662201948745153615022283660404290507739148252316445179146250754853317790538595219213683260840093088946711563827879340831180
k = 1766475861799342086302676800592071348935577758712245949146337851211476176148172462414189619404387001501651004144430269084218984354996511392416069223595208291891735241426368903080140232510868818396517450511831918224745632622944109726370038097845771146484546980780391254338136512209523985617501629741723799586245469665007917180256416254729297592709728459794962234801848185666601505009343977947915509620725639905914641747531796489144762841555567065192755665878639248197890499396909289

p, q = var("p, q")
assume(p, "integer")
assume(q, "integer")
sol = solve((p - 1003) ** 2 + (q - 48) ** 2 == k, p, q)

for p, q in sol:
    if p > 0 and q > 0:
        p, q = int(p), int(q)
        if isPrime(p) and isPrime(q):
            d = inverse_mod(0x10001, (p-1)*(q-1))
            print(long_to_bytes(pow(c, d, p*q)).decode())
